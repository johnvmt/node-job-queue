{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/IndexedLinkedList.js","src/JobsQueue.js"],"names":["IndexedLinkedList","this","list","length","head","tail","prototype","peek","data","Error","get","index","hasIndex","forEach","callback","item","next","dequeue","_removeItem","remove","push","_resetIndex","prev","enqueue","error","_set","undefined","module","exports","JobsQueue","passedOptions","defaultOptions","maxSimultaneous","options","_objectMerge","queuedJobList","inprogressJobList","inprogress","queued","require","_tryStartNextJob","maxFromArray","maxList","limitedMaxList","filter","maxFromOption","Math","min","apply","maxInProgress","globalMaxSimultaneous","inprogressMaxSimultaneous","job","nextJob","nextJobMaxSimultaneous","jobId","_startJob","jobRestarts","restarts","start","controller","complete","_finishJob","self","_uniqueId","jobController","cancel","restart","newCallback","_objectForEach","object","property","hasOwnProperty","merged","arguments","argument","attrname","s4","floor","random","toString","substring"],"mappings":"AAAA;ACAA,QAASA,qBACRC,KAAKC,QACLD,KAAKE,OAAS,EACdF,KAAKG,KAAO,KACZH,KAAKI,KAAO,KAMbL,kBAAkBM,UAAUC,KAAO,WAClC,GAAGN,KAAKE,OAAS,EAChB,MAAOF,MAAKG,KAAKI,IAEjB,MAAM,IAAIC,OAAM,eAMlBT,kBAAkBM,UAAUI,IAAM,SAASC,GAC1C,GAAIV,KAAKW,SAASD,GAGjB,MAAOV,MAAKC,KAAKS,GAAOH,IAFxB,MAAM,IAAIC,OAAM,oBAQlBT,kBAAkBM,UAAUM,SAAW,SAASD,GAC/C,MAAmC,gBAApBV,MAAKC,KAAKS,IAM1BX,kBAAkBM,UAAUO,QAAU,SAASC,GAE9C,IADA,GAAIC,GAAOd,KAAKG,KACF,MAARW,GACLD,EAASC,EAAKP,MACdO,EAAOA,EAAKC,MAOdhB,kBAAkBM,UAAUW,QAAU,WACrC,MAAOhB,MAAKiB,YAAYjB,KAAKG,OAO9BJ,kBAAkBM,UAAUa,OAAS,SAASR,GAC7CV,KAAKiB,YAAYjB,KAAKC,KAAKS,KAQ5BX,kBAAkBM,UAAUc,KAAO,SAAST,EAAOH,GAClD,GAAIO,GAAOd,KAAKoB,YAAYV,EAAOH,EAGnB,OAAbP,KAAKG,OACPH,KAAKG,KAAKkB,KAAOP,GAElBA,EAAKO,KAAO,KACZP,EAAKC,KAAOf,KAAKG,KAEjBH,KAAKG,KAAOW,EAEM,GAAfd,KAAKE,SACPF,KAAKI,KAAOU,GAGbd,KAAKE,UAQNH,kBAAkBM,UAAUiB,QAAU,SAASZ,EAAOH,GACrD,GAAIO,GAAOd,KAAKoB,YAAYV,EAAOH,EAGnB,OAAbP,KAAKI,OACPJ,KAAKI,KAAKW,KAAOD,GAElBA,EAAKC,KAAO,KACZD,EAAKO,KAAOrB,KAAKI,KAEjBJ,KAAKI,KAAOU,EAEM,GAAfd,KAAKE,SACPF,KAAKG,KAAOW,GAGbd,KAAKE,UASNH,kBAAkBM,UAAUe,YAAc,SAASV,EAAOH,GAEzD,IACCP,KAAKkB,OAAOR,GAEb,MAAMa,IAGN,MAAOvB,MAAKwB,KAAKd,EAAOH,IASzBR,kBAAkBM,UAAUmB,KAAO,SAASd,EAAOH,GAWlD,MAV8B,gBAApBP,MAAKC,KAAKS,GACnBV,KAAKC,KAAKS,GAAOH,KAAOA,EAExBP,KAAKC,KAAKS,IACTH,KAAMA,EACNQ,SAAMU,GACNJ,SAAMI,IAIDzB,KAAKC,KAAKS,IASlBX,kBAAkBM,UAAUY,YAAc,SAASH,GAClD,GAAkB,gBAARA,IAA4B,MAARA,EAC7B,KAAM,IAAIN,OAAM,iBAchB,OAXgB,OAAbM,EAAKC,KACPf,KAAKI,KAAOU,EAAKO,KAEjBP,EAAKC,KAAKM,KAAOP,EAAKO,KAEP,MAAbP,EAAKO,KACPrB,KAAKG,KAAOW,EAAKC,KAEjBD,EAAKO,KAAKN,KAAOD,EAAKC,KAEvBf,KAAKE,SACEY,EAAKP,MAIdmB,OAAOC,QAAU,WAChB,MAAO,IAAI5B;;AC1KZ,QAAS6B,WAAUC,GAClB,GAAIC,IACHC,gBAAiB,EAGlB/B,MAAKgC,QAAUhC,KAAKiC,aAAaH,EAAgBD,GAEjD7B,KAAKkC,cAAgBnC,oBACrBC,KAAKmC,kBAAoBpC,oBAEzBC,KAAKoC,WAAa,EAClBpC,KAAKqC,OAAS,EAbf,GAAItC,mBAAoBuC,QAAQ,sBAgBhCV,WAAUvB,UAAUkC,iBAAmB,WA4BtC,QAASC,GAAaC,GACrB,GAAIC,GAAiBD,EAAQE,OAAO,SAASZ,GAC5C,MAAOa,GAAcb,GAAmB,GAEzC,OAAQW,GAAexC,OAAS,EAAK2C,KAAKC,IAAIC,MAAM,KAAML,GAAkB,EAG7E,QAASE,GAAcI,GACtB,MAAgC,gBAAjBA,IAA6BA,EAAgB,EAAKA,EAAgB,EAnClF,GAAGhD,KAAKkC,cAAchC,OAAQ,CAE7B,GAAI+C,GAAwBL,EAAc5C,KAAKgC,QAAQD,iBAEnDmB,EAA4B,CAChClD,MAAKmC,kBAAkBvB,QAAQ,SAASuC,GACvCD,EAA4BV,GAAcU,EAA2BC,EAAInB,QAAQD,mBAGlF,IAAIqB,GAAUpD,KAAKkC,cAAc5B,OAC7B+C,EAAyBT,EAAcQ,EAAQpB,QAAQD,iBAEvDA,EAAkBS,GAAcS,EAAuBC,EAA2BG,GAEtF,IAAGtB,GAAmB,GAAK/B,KAAKoC,WAAaL,EAAiB,CAC7D,GAAIoB,GAAMnD,KAAKkC,cAAclB,SAC7BhB,MAAKqC,SAELrC,KAAKmC,kBAAkBb,QAAQ6B,EAAIG,MAAOH,GAC1CnD,KAAKoC,aAELpC,KAAKuD,UAAUJ,EAAIG,OAEnBtD,KAAKuC,sBAgBRX,UAAUvB,UAAUkD,UAAY,SAASD,GACxC,GAAGtD,KAAKmC,kBAAkBxB,SAAS2C,GAAQ,CAC1C,GAAIH,GAAMnD,KAAKmC,kBAAkB1B,IAAI6C,GACjCE,EAAcL,EAAIM,QAEtBN,GAAIO,MAAM,WACNF,GAAeL,EAAIM,UACrBN,EAAIQ,WAAWC,eAKnBhC,UAAUvB,UAAUwD,WAAa,SAASP,GACzC,GAAGtD,KAAKmC,kBAAkBxB,SAAS2C,GAClCtD,KAAKmC,kBAAkBjB,OAAOoC,GAC9BtD,KAAKoC,aACLpC,KAAKuC,uBAED,CAAA,IAAGvC,KAAKkC,cAAcvB,SAAS2C,GAMnC,KAAM,IAAI9C,OAAM,gBALhBR,MAAKkC,cAAchB,OAAOoC,GAC1BtD,KAAKqC,SACLrC,KAAKuC,qBAMPX,UAAUvB,UAAUiB,QAAU,SAAST,EAAUmB,GAChD,GAAI8B,GAAO9D,KACPsD,EAAQtD,KAAK+D,YAEbZ,GACHG,MAAOA,EACPI,MAAO7C,EACP4C,SAAU,EACVzB,QAAS8B,EAAK7B,gBAAiBD,IAG5BgC,GACHC,OAAQ,WACPH,EAAKD,WAAWP,IAEjBM,SAAU,WACTE,EAAKD,WAAWP,IAEjBY,QAAS,SAASC,GACQ,kBAAfA,KACThB,EAAIO,MAAQS,GACbhB,EAAIM,WACJK,EAAKP,UAAUD,IAYjB,OARAH,GAAIQ,WAAaK,EAEjBF,EAAK5B,cAAcZ,QAAQgC,EAAOH,GAElCnD,KAAKqC,SAELrC,KAAKuC,mBAEEyB,GAGRpC,UAAUvB,UAAU+D,eAAiB,SAASC,EAAQxD,GAErD,GAAIyD,EACJ,KAAIA,IAAYD,GACXA,EAAOE,eAAeD,IACzBzD,EAASwD,EAAOC,GAAWA,EAAUD,IAIxCzC,UAAUvB,UAAU4B,aAAe,WAClC,GAAIuC,KAOJ,OANAxE,MAAKoE,eAAeK,UAAW,SAASC,GACvC,IAAK,GAAIC,KAAYD,GACjBA,EAASH,eAAeI,KAC1BH,EAAOG,GAAYD,EAASC,MAGxBH,GAGR5C,UAAUvB,UAAU0D,UAAY,WAC/B,QAASa,KACR,MAAO/B,MAAKgC,MAA4B,OAArB,EAAIhC,KAAKiC,WAC1BC,SAAS,IACTC,UAAU,GAEb,MAAOJ,KAAOA,IAAO,IAAMA,IAAO,IAAMA,IAAO,IAC9CA,IAAO,IAAMA,IAAOA,IAAOA,KAG7BlD,OAAOC,QAAU,SAASK,GACzB,MAAO,IAAIJ,WAAUI","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","function IndexedLinkedList() {\n\tthis.list = {};\n\tthis.length = 0;\n\tthis.head = null;\n\tthis.tail = null;\n}\n\n/**\n * Peek at head, without removing it\n */\nIndexedLinkedList.prototype.peek = function () {\n\tif(this.length > 0)\n\t\treturn this.head.data;\n\telse\n\t\tthrow new Error('list_empty');\n};\n\n/**\n * Get item with given index, if it exists\n */\nIndexedLinkedList.prototype.get = function(index) {\n\tif(!this.hasIndex(index))\n\t\tthrow new Error('index_undefined');\n\telse\n\t\treturn this.list[index].data;\n};\n\n/**\n * Check if item with given index exists\n */\nIndexedLinkedList.prototype.hasIndex = function(index) {\n\treturn (typeof this.list[index] == 'object');\n};\n\n/**\n * Iterate over list, starting at head\n */\nIndexedLinkedList.prototype.forEach = function(callback) {\n\tvar item = this.head;\n\twhile(item != null) {\n\t\tcallback(item.data);\n\t\titem = item.next;\n\t}\n};\n\n/**\n * Remove from head\n */\nIndexedLinkedList.prototype.dequeue = function() {\n\treturn this._removeItem(this.head);\n};\n\n/**\n * Remove item at given index\n * @param index\n */\nIndexedLinkedList.prototype.remove = function(index) {\n\tthis._removeItem(this.list[index]);\n};\n\n/**\n * Add at head\n * @param index\n * @param data\n */\nIndexedLinkedList.prototype.push = function(index, data) {\n\tvar item = this._resetIndex(index, data);\n\n\t// Link it to the list\n\tif(this.head != null)\n\t\tthis.head.prev = item;\n\n\titem.prev = null;\n\titem.next = this.head;\n\n\tthis.head = item;\n\n\tif(this.length == 0)\n\t\tthis.tail = item;\n\n\t// Change the list length\n\tthis.length++;\n};\n\n/**\n * Add at tail\n * @param index\n * @param data\n */\nIndexedLinkedList.prototype.enqueue = function(index, data) {\n\tvar item = this._resetIndex(index, data);\n\n\t// Link it to the list\n\tif(this.tail != null)\n\t\tthis.tail.next = item;\n\n\titem.next = null;\n\titem.prev = this.tail;\n\n\tthis.tail = item;\n\n\tif(this.length == 0)\n\t\tthis.head = item;\n\n\t// Change the list length\n\tthis.length++;\n};\n\n/**\n * Unlink the item from the list, if it exists\n * @param index\n * @param data\n * @private\n */\nIndexedLinkedList.prototype._resetIndex = function(index, data) {\n\t// Remove the item if it exists\n\ttry {\n\t\tthis.remove(index);\n\t}\n\tcatch(error) {}\n\n\t// Add the item to the list\n\treturn this._set(index, data);\n};\n\n/**\n * Set the data for an item; create the item if it doesn't exist\n * @param index\n * @param data\n * @private\n */\nIndexedLinkedList.prototype._set = function(index, data) {\n\tif(typeof this.list[index] == 'object') // item already exists\n\t\tthis.list[index].data = data;\n\telse {\n\t\tthis.list[index] = {\n\t\t\tdata: data,\n\t\t\tnext: undefined,\n\t\t\tprev: undefined\n\t\t}\n\t}\n\n\treturn this.list[index];\n};\n\n/**\n * Remove given item from the list\n * @param item\n * @returns {*|string|CanvasPixelArray|Object[]}\n * @private\n */\nIndexedLinkedList.prototype._removeItem = function(item) {\n\tif(typeof item != 'object' || item == null)\n\t\tthrow new Error('undefined_item');\n\telse {\n\t\t// Set next item's prev to current item's prev\n\t\tif(item.next == null) // item is at tail\n\t\t\tthis.tail = item.prev;\n\t\telse // item is not at tail\n\t\t\titem.next.prev = item.prev;\n\n\t\tif(item.prev == null) // item is at head\n\t\t\tthis.head = item.next;\n\t\telse // item is not at head\n\t\t\titem.prev.next = item.next;\n\n\t\tthis.length--;\n\t\treturn item.data;\n\t}\n};\n\nmodule.exports = function() {\n\treturn new IndexedLinkedList();\n};","var IndexedLinkedList = require('./IndexedLinkedList');\n\nfunction JobsQueue(passedOptions) {\n\tvar defaultOptions = {\n\t\tmaxSimultaneous: 1\n\t};\n\n\tthis.options = this._objectMerge(defaultOptions, passedOptions)\n\n\tthis.queuedJobList = IndexedLinkedList();\n\tthis.inprogressJobList = IndexedLinkedList();\n\n\tthis.inprogress = 0;\n\tthis.queued = 0;\n}\n\nJobsQueue.prototype._tryStartNextJob = function() {\n\tif(this.queuedJobList.length) {\n\t\t// Get max simultaneous jobs from jobs in progress, next job in queue, global max; take min of these to get max\n\t\tvar globalMaxSimultaneous = maxFromOption(this.options.maxSimultaneous);\n\n\t\tvar inprogressMaxSimultaneous = 0;\n\t\tthis.inprogressJobList.forEach(function(job) {\n\t\t\tinprogressMaxSimultaneous = maxFromArray([inprogressMaxSimultaneous, job.options.maxSimultaneous]);\n\t\t});\n\n\t\tvar nextJob = this.queuedJobList.peek();\n\t\tvar nextJobMaxSimultaneous = maxFromOption(nextJob.options.maxSimultaneous);\n\n\t\tvar maxSimultaneous = maxFromArray([globalMaxSimultaneous, inprogressMaxSimultaneous, nextJobMaxSimultaneous]);\n\n\t\tif(maxSimultaneous <= 0 || this.inprogress < maxSimultaneous) { // Start the next job\n\t\t\tvar job = this.queuedJobList.dequeue(); // Remove from the queued jobs list\n\t\t\tthis.queued--;\n\n\t\t\tthis.inprogressJobList.enqueue(job.jobId, job); // Add to the jobs in progress list, with same ID\n\t\t\tthis.inprogress++;\n\n\t\t\tthis._startJob(job.jobId);\n\n\t\t\tthis._tryStartNextJob(); // May be able to run jobs simultaneously\n\t\t}\n\t}\n\n\tfunction maxFromArray(maxList) {\n\t\tvar limitedMaxList = maxList.filter(function(maxSimultaneous) {\n\t\t\treturn maxFromOption(maxSimultaneous) > 0;\n\t\t});\n\t\treturn (limitedMaxList.length > 0) ? Math.min.apply(null, limitedMaxList) : 0;\n\t}\n\n\tfunction maxFromOption(maxInProgress) {\n\t\treturn (typeof maxInProgress == 'number' && maxInProgress > 0) ? maxInProgress : 0;\n\t}\n};\n\nJobsQueue.prototype._startJob = function(jobId) {\n\tif(this.inprogressJobList.hasIndex(jobId)) {\n\t\tvar job = this.inprogressJobList.get(jobId);\n\t\tvar jobRestarts = job.restarts;\n\n\t\tjob.start(function() { // Start the job and pass in the callback to finish the job\n\t\t\tif(jobRestarts == job.restarts) // Check if job started was the last one\n\t\t\t\tjob.controller.complete();\n\t\t});\n\t}\n};\n\nJobsQueue.prototype._finishJob = function(jobId) {\n\tif(this.inprogressJobList.hasIndex(jobId)) {\n\t\tthis.inprogressJobList.remove(jobId);\n\t\tthis.inprogress--;\n\t\tthis._tryStartNextJob();\n\t}\n\telse if(this.queuedJobList.hasIndex(jobId)) {\n\t\tthis.queuedJobList.remove(jobId);\n\t\tthis.queued--;\n\t\tthis._tryStartNextJob();\n\t}\n\telse\n\t\tthrow new Error('job_not_found');\n};\n\nJobsQueue.prototype.enqueue = function(callback, options) {\n\tvar self = this;\n\tvar jobId = this._uniqueId();\n\n\tvar job = {\n\t\tjobId: jobId,\n\t\tstart: callback, // Wrap function to ensure uniqueness when job finishes\n\t\trestarts: 0,\n\t\toptions: self._objectMerge({}, options),\n\t}\n\n\tvar jobController = {\n\t\tcancel: function() {\n\t\t\tself._finishJob(jobId);\n\t\t},\n\t\tcomplete: function() {\n\t\t\tself._finishJob(jobId);\n\t\t},\n\t\trestart: function(newCallback) {\n\t\t\tif(typeof newCallback == 'function')\n\t\t\t\tjob.start = newCallback;\n\t\t\tjob.restarts++;\n\t\t\tself._startJob(jobId); // Restart if already in progress\n\t\t}\n\t};\n\n\tjob.controller = jobController;\n\n\tself.queuedJobList.enqueue(jobId, job);\n\n\tthis.queued++;\n\n\tthis._tryStartNextJob();\n\n\treturn jobController;\n};\n\nJobsQueue.prototype._objectForEach = function(object, callback) {\n\t// run function on each property (child) of object\n\tvar property;\n\tfor(property in object) { // pull keys before looping through?\n\t\tif (object.hasOwnProperty(property))\n\t\t\tcallback(object[property], property, object);\n\t}\n};\n\nJobsQueue.prototype._objectMerge = function() {\n\tvar merged = {};\n\tthis._objectForEach(arguments, function(argument) {\n\t\tfor (var attrname in argument) {\n\t\t\tif(argument.hasOwnProperty(attrname))\n\t\t\t\tmerged[attrname] = argument[attrname];\n\t\t}\n\t});\n\treturn merged;\n};\n\nJobsQueue.prototype._uniqueId = function() {\n\tfunction s4() {\n\t\treturn Math.floor((1 + Math.random()) * 0x10000)\n\t\t\t.toString(16)\n\t\t\t.substring(1);\n\t}\n\treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n\t\ts4() + '-' + s4() + s4() + s4();\n};\n\nmodule.exports = function(options) {\n\treturn new JobsQueue(options);\n};"]}