{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/JobsQueue.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\r\nfunction JobsQueue(passedOptions) {\r\n\tvar defaultOptions = {\r\n\t\tmaxSimultaneous: 1\r\n\t};\r\n\r\n\tthis.options = Object.assign(defaultOptions, passedOptions)\r\n\r\n\tthis.queuedJobList = []; // IndexedLinkedList();\r\n\tthis.inprogressJobList = []; // IndexedLinkedList();\r\n\r\n\tthis.inprogress = 0;\r\n\tthis.queued = 0;\r\n}\r\n\r\nJobsQueue.prototype._tryStartNextJob = function() {\r\n\tif(this.queuedJobList.length > 0) {\r\n\t\t// Get max simultaneous jobs from jobs in progress, next job in queue, global max; take min of these to get max\r\n\t\tvar globalMaxSimultaneous = maxFromOption(this.options.maxSimultaneous);\r\n\r\n\t\tvar inprogressMaxSimultaneous = 0;\r\n\t\tthis.inprogressJobList.forEach(function(job) {\r\n\t\t\tinprogressMaxSimultaneous = maxFromArray([inprogressMaxSimultaneous, job.options.maxSimultaneous]);\r\n\t\t});\r\n\r\n\t\tvar nextJob = this.queuedJobList[0]; // peek\r\n\t\tvar nextJobMaxSimultaneous = maxFromOption(nextJob.options.maxSimultaneous);\r\n\r\n\t\tvar maxSimultaneous = maxFromArray([globalMaxSimultaneous, inprogressMaxSimultaneous, nextJobMaxSimultaneous]);\r\n\r\n\t\tif(maxSimultaneous <= 0 || this.inprogress < maxSimultaneous) { // Start the next job\r\n\t\t\tvar job = this.queuedJobList.shift(); // Remove from the queued jobs list\r\n\t\t\tthis.queued--;\r\n\r\n\t\t\tthis.inprogressJobList.push(job); // Add to the jobs in progress list, with same ID\r\n\t\t\tthis.inprogress++;\r\n\r\n\t\t\tthis._startJob(job.jobId);\r\n\r\n\t\t\tthis._tryStartNextJob(); // May be able to run jobs simultaneously\r\n\t\t}\r\n\t}\r\n\r\n\tfunction maxFromArray(maxList) {\r\n\t\tvar limitedMaxList = maxList.filter(function(maxSimultaneous) {\r\n\t\t\treturn maxFromOption(maxSimultaneous) > 0;\r\n\t\t});\r\n\t\treturn (limitedMaxList.length > 0) ? Math.min.apply(null, limitedMaxList) : 0;\r\n\t}\r\n\r\n\tfunction maxFromOption(maxInProgress) {\r\n\t\treturn (typeof maxInProgress == 'number' && maxInProgress > 0) ? maxInProgress : 0;\r\n\t}\r\n};\r\n\r\nJobsQueue.prototype._startJob = function(jobId) {\r\n\tlet job = this.inprogressJobList.find(j => j.jobId = jobId)\r\n\tif (job) {\r\n\t\tvar jobRestarts = job.restarts;\r\n\r\n\t\tjob.start(function() { // Start the job and pass in the callback to finish the job\r\n\t\t\tif(jobRestarts == job.restarts) // Check if job started was the last one\r\n\t\t\t\tjob.controller.complete();\r\n\t\t});\r\n\t}\r\n};\r\n\r\nJobsQueue.prototype._finishJob = function(jobId) {\r\n\tlet jobIndexP = this.inprogressJobList.findIndex(j => j.jobIndex === jobId)\r\n\tif (jobIndexP >= 0) {\r\n\t\tthis.inprogressJobList.splice(jobIndexP, 1);\r\n\t\tthis.inprogress--;\r\n\t\tthis._tryStartNextJob();\r\n\t\treturn;\r\n\t}\r\n\tlet jobIndexQ = this.queuedJobList.findIndex(j => j.jobId === jobId)\r\n\tif (jobIndexQ >= 0) {\r\n\t\tthis.queuedJobList.splice(jobIndexQ, 1);\r\n\t\tthis.queued--;\r\n\t\tthis._tryStartNextJob();\r\n\t\treturn;\r\n\t}\r\n\tthrow new Error('job_not_found');\r\n};\r\n\r\nJobsQueue.prototype.enqueue = function(callback, options) {\r\n\tvar self = this;\r\n\tvar jobId = this._uniqueId();\r\n\r\n\tvar job = {\r\n\t\tjobId: jobId,\r\n\t\tstart: callback, // Wrap function to ensure uniqueness when job finishes\r\n\t\trestarts: 0,\r\n\t\toptions: Object.assign({}, options),\r\n\t}\r\n\r\n\tvar jobController = {\r\n\t\tcancel: function() {\r\n\t\t\tself._finishJob(jobId);\r\n\t\t},\r\n\t\tcomplete: function() {\r\n\t\t\tself._finishJob(jobId);\r\n\t\t},\r\n\t\trestart: function(newCallback) {\r\n\t\t\tif(typeof newCallback == 'function')\r\n\t\t\t\tjob.start = newCallback;\r\n\t\t\tjob.restarts++;\r\n\t\t\tself._startJob(jobId); // Restart if already in progress\r\n\t\t}\r\n\t};\r\n\r\n\tjob.controller = jobController;\r\n\r\n\tself.queuedJobList.push(job);\r\n\r\n\tthis.queued++;\r\n\r\n\tthis._tryStartNextJob();\r\n\r\n\treturn jobController;\r\n};\r\n\r\nJobsQueue.prototype._objectForEach = function(object, callback) {\r\n\t// run function on each property (child) of object\r\n\tvar property;\r\n\tfor(property in object) { // pull keys before looping through?\r\n\t\tif (object.hasOwnProperty(property))\r\n\t\t\tcallback(object[property], property, object);\r\n\t}\r\n};\r\n\r\nJobsQueue.prototype._uniqueId = function() {\r\n\tfunction s4() {\r\n\t\treturn Math.floor((1 + Math.random()) * 0x10000)\r\n\t\t\t.toString(16)\r\n\t\t\t.substring(1);\r\n\t}\r\n\treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' +\r\n\t\ts4() + '-' + s4() + s4() + s4();\r\n};\r\n\r\nmodule.exports = function(options) {\r\n\treturn new JobsQueue(options);\r\n};\r\n"]}